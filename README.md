# team_proj
Team work training: new branches, parallel coding, pulls, merges.

***
Materials from
["Git Branching"](https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell)

Материалы с
["Ветвление в Git"](https://git-scm.com/book/ru/v2/%D0%92%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-Git-%D0%9E-%D0%B2%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B8-%D0%B2-%D0%B4%D0%B2%D1%83%D1%85-%D1%81%D0%BB%D0%BE%D0%B2%D0%B0%D1%85)

***

__Содержание__

1. [Введение](#введение)\
    1.1 [Создание новой ветки: _git branch_](#создание-новой-ветки)  
    1.2 [Переключение веток: _git checkout_](#переключение-веток)
2. [Ветвление в Git](#основы-ветвления-и-слияния) \
    2.1 [Ветвление в Git: _git branch/checkout_](#основы-ветвления-и-слияния)  
    2.2 [Основы слияния: _git merge_](#основы-слияния)  
    2.3 [Основные конфликты слияния](https://git-scm.com/book/ru/v2/%D0%92%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-Git-%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-%D0%B2%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8-%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D1%8F#:~:text=%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5%20%D0%BA%D0%BE%D0%BD%D1%84%D0%BB%D0%B8%D0%BA%D1%82%D1%8B%20%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D1%8F)
3. [Управление ветками](#управление-ветками) \
    3.1 [Управление ветками: _git branch -v_](#управление-ветками)  
    3.2 [Переименование ветки: _git branch --move_](#переименование-ветки)
4. [Работа с ветками](https://git-scm.com/book/ru/v2/%D0%92%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-Git-%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-%D0%B2%D0%B5%D1%82%D0%BA%D0%B0%D0%BC%D0%B8)
    

***
## Введение

Ветка в Git — это простой перемещаемый указатель на один из таких коммитов. По умолчанию, имя основной ветки в Git — master. Как только вы начнёте создавать коммиты, ветка master будет всегда указывать на последний коммит. Каждый раз при создании коммита указатель ветки master будет передвигаться на следующий коммит автоматически.

Ветка в Git — это простой файл, содержащий 40 символов контрольной суммы `SHA-1` коммита, на который она указывает; поэтому операции с ветками являются дешёвыми с точки зрения потребления ресурсов или времени. Создание новой ветки в Git происходит так же быстро и просто как запись 41 байта в файл (40 знаков и перевод строки).

***
### Создание новой ветки
***

Что же на самом деле происходит при создании ветки? Всего лишь создаётся новый указатель для дальнейшего перемещения. Допустим вы хотите создать новую ветку с именем testing. Вы можете это сделать командой `git branch`:

    $ git branch testing

В результате создаётся новый указатель на текущий коммит.

***
### Переключение веток
***

Для переключения на существующую ветку выполните команду `git checkout`. Давайте переключимся на ветку `t`esting`:

    $ git checkout testing

В результате указатель `HEAD` переместится на ветку `testing`.

***
### История коммитов
***

Для отображения истории коммитов, текущего положения указателей веток и истории ветвления выполните команду `git log --oneline --decorate --graph --all`.

    $ git log --oneline --decorate --graph --all
    * c2b9e (HEAD, master) Made other changes
    | * 87ab2 (testing) Made a change
    |/
    * f30ab Add feature #32 - ability to add new formats to the central interface
    * 34ac2 Fix bug #1328 - stack overflow under certain conditions
    * 98ca9 initial commit of my project

Чтобы создать ветку и сразу переключиться на неё, можно выполнить команду `git checkout` с параметром `-b`:

    $ git checkout -b iss53
    Switched to a new branch "iss53"

Это то же самое что и:

    $ git branch iss53
    $ git checkout iss53

***
## Основы ветвления и слияния

Создание ветки `iss53` как ответвление от ветки `master`, работа в `iss53` и коммит:

    $ git checkout -b iss53
    Switched to a new branch "iss53"
    $ git branch iss53
    $ git checkout iss53
    $ vim index.html
    $ git commit -a -m 'Create new footer [issue 53]'

Создание ветки `hotfix` как ответвление от ветки `master`, работа в `hotfix` и коммит:

    $ git checkout master
    Switched to branch 'master'
    $ git checkout -b hotfix
    Switched to a new branch 'hotfix'
    $ vim index.html
    $ git commit -a -m 'Fix broken email address'
    [hotfix 1fb7853] Fix broken email address
    1 file changed, 2 insertions(+)

Слияние веток `master` и `hotfix` (перемещение указателя `master` на коммит, на который указывает `hotfix`)

    $ git checkout master
    $ git merge hotfix
    Updating f42c576..3a0874c
    Fast-forward
    index.html | 2 ++
    1 file changed, 2 insertions(+)

Git просто переместил указатель ветки вперед, потому что коммит, на который указывает слитая ветка `hotfix`, был прямым потомком коммита, на котором вы находились до этого. Другими словами, если коммит сливается с тем, до которого можно добраться двигаясь по истории прямо, Git упрощает слияние просто перенося указатель ветки вперед, так как нет расхождений в изменениях. Это называется `«fast-forward»`.

После внедрения вашего архиважного исправления, вы готовы вернуться к работе над тем, что были вынуждены отложить. Но сначала нужно удалить ветку `hotfix`, потому что она больше не нужна — ветка `master` указывает на то же самое место. Для удаления ветки выполните команду `git branch` с параметром `-d`:

    $ git branch -d hotfix
    Deleted branch hotfix (3a0874c).

Теперь вы можете переключиться обратно на ветку `iss53` и продолжить работу над проблемой #53:

    $ git checkout iss53
    Switched to branch "iss53"
    $ vim index.html
    $ git commit -a -m 'Finish the new footer [issue 53]'
    [iss53 ad82d7a] Finish the new footer [issue 53]
    1 file changed, 1 insertion(+)

Стоит обратить внимание на то, что все изменения из ветки `hotfix` не включены в вашу ветку `iss53`. Если их нужно включить, вы можете влить ветку `master` в вашу ветку `iss53` командой `git merge master`, или же вы можете отложить слияние этих изменений до завершения работы, и затем влить ветку `iss53` в `master`.

***
### Основы слияния
***

Предположим, вы решили, что работа по проблеме #53 закончена и её можно влить в ветку `master`. Для этого нужно выполнить слияние ветки `iss53` точно так же, как вы делали это с веткой `hotfix` ранее. Все, что нужно сделать — переключиться на ветку, в которую вы хотите включить изменения, и выполнить команду `git merge`:

    $ git checkout master
    Switched to branch 'master'
    $ git merge iss53
    Merge made by the 'recursive' strategy.
    index.html |    1 +
    1 file changed, 1 insertion(+)

Результат этой операции отличается от результата слияния ветки `hotfix`. В данном случае процесс разработки ответвился в более ранней точке. Так как коммит, на котором мы находимся, не является прямым родителем ветки, с которой мы выполняем слияние, Git придётся немного потрудиться. В этом случае Git выполняет простое трёхстороннее слияние, используя последние коммиты объединяемых веток и общего для них родительского коммита.

Вместо того, чтобы просто передвинуть указатель ветки вперёд, Git создаёт новый результирующий снимок трёхстороннего слияния, а затем автоматически делает коммит. Этот особый коммит называют коммитом слияния, так как у него более одного предка.

Теперь, когда изменения слиты, ветка `iss53` больше не нужна. Вы можете закрыть задачу в системе отслеживания ошибок и удалить ветку:

    $ git branch -d iss53

***
### [Основные конфликты слияния](https://git-scm.com/book/ru/v2/%D0%92%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-Git-%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-%D0%B2%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8-%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D1%8F#:~:text=%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5%20%D0%BA%D0%BE%D0%BD%D1%84%D0%BB%D0%B8%D0%BA%D1%82%D1%8B%20%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D1%8F)

***
## Управление ветками

Команда `git branch` делает несколько больше, чем просто создаёт и удаляет ветки. При запуске без параметров, вы получите простой список имеющихся у вас веток:

    $ git branch
      iss53
    * master
      testing

Символ *, стоящий перед веткой `master` указывает на ветку, на которой вы находитесь в настоящий момент (т. е. ветку, на которую указывает `HEAD`). Это означает, что если вы сейчас сделаете коммит, ветка `master` переместится вперёд в соответствии с вашими последними изменениями. Чтобы посмотреть последний коммит на каждой из веток, выполните команду `git branch -v`:

    $ git branch -v
      iss53   93b412c Fix javascript issue
    * master  7a98805 Merge branch 'iss53'
      testing 782fd34 Add scott to the author list in the readme

Опции `--merged` и `--no-merged` могут отфильтровать этот список для вывода только тех веток, которые слиты или ещё не слиты в текущую ветку. Чтобы посмотреть те ветки, которые вы уже слили с текущей, можете выполнить команду `git branch --merged`:

    $ git branch --merged
      iss53
    * master

Ветка `iss53` присутствует в этом списке потому что вы ранее слили её в `master`. Те ветки из этого списка, перед которыми нет символа `*`, можно смело удалять командой `git branch -d`; наработки из этих веток уже включены в другую ветку, так что ничего не потеряется.

Чтобы увидеть все ветки, содержащие наработки, которые вы пока ещё не слили в текущую ветку, выполните команду `git branch --no-merged`:

    $ git branch --no-merged
      testing

Вы увидите оставшуюся ветку. Так как она содержит ещё не слитые наработки, попытка удалить её командой `git branch -d` приведёт к ошибке:

    $ git branch -d testing
    error: The branch 'testing' is not fully merged.
    If you are sure you want to delete it, run 'git branch -D testing'.

Если вы действительно хотите удалить ветку вместе со всеми наработками, используйте опцию `-D`, как указано в подсказке.

***
### Переименование ветки
***

Предположим, у вас есть ветка с именем `bad-branch-name`, и вы хотите изменить её на `corrected-branch-name`, сохранив при этом всю историю. Вместе с этим, вы также хотите изменить имя ветки на удалённом сервере (GitHub, GitLab или другой сервер). Как это сделать?

Переименуйте ветку локально с помощью команды `git branch --move`:

    $ git branch --move bad-branch-name corrected-branch-name

Ветка `bad-branch-name` будет переименована в `corrected-branch-name`, но это изменение пока только локальное. Чтобы все остальные увидели исправленную ветку в удалённом репозитории, отправьте её туда:

    $ git push --set-upstream origin corrected-branch-name

Теперь проверим, где мы сейчас находимся:

    $ git branch --all
    * corrected-branch-name
      main
      remotes/origin/bad-branch-name
      remotes/origin/corrected-branch-name
      remotes/origin/main

Обратите внимание, что текущая ветка `corrected-branch-name`, которая также присутствует и на удалённом сервере. Однако, старая ветка всё ещё по-прежнему там, но её можно удалить с помощью команды:

    $ git push origin --delete bad-branch-name

Теперь старое имя ветки полностью заменено исправленным.

***
## [Работа с ветками](https://git-scm.com/book/ru/v2/%D0%92%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-Git-%D0%A0%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-%D0%B2%D0%B5%D1%82%D0%BA%D0%B0%D0%BC%D0%B8)

***
## Удалённые ветки

Удалённые ссылки — это ссылки (указатели) в ваших удалённых репозиториях, включая ветки, теги и так далее. Полный список удалённых ссылок можно получить с помощью команды `git ls-remote <remote>` или команды `git remote show <remote>` для получения удалённых веток и дополнительной информации. Тем не менее, более распространённым способом является использование веток слежения.

Ветки слежения — это ссылки на определённое состояние удалённых веток. Это локальные ветки, которые нельзя перемещать; Git перемещает их автоматически при любой коммуникации с удалённым репозиторием, чтобы гарантировать точное соответствие с ним. Представляйте их как закладки для напоминания о том, где ветки в удалённых репозиториях находились во время последнего подключения к ним.

Имена веток слежения имеют вид `<remote>/<branch>`. Например, если вы хотите посмотреть, как выглядела ветка master на сервере origin во время последнего соединения с ним, используйте ветку `origin/master`. Если вы с коллегой работали над одной задачей и он отправил на сервер ветку `iss53`, при том что у вас может быть своя локальная ветка `iss53`, удалённая ветка будет представлена веткой слежения с именем `origin/iss53`.
